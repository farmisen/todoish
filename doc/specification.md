### **Specifications for todoish**

**Version:** 1.0
**Date:** 7/29/2025

### 1. Introduction

#### 1.1 Purpose
This document provides the detailed software requirements for **todoish**, a command-line task manager. The system is designed as a reference implementation to demonstrate the principles of clean, layered software architecture. Its primary goal is educational, showcasing how separation of concerns leads to a maintainable and scalable application.

#### 1.2 Scope
The system will provide users with the ability to manage a personal to-do list via a Command-Line Interface (CLI). The core functionalities include adding, listing, completing, and removing tasks. All task data will be persisted locally in a JSON file to ensure data integrity between sessions.

#### 1.3 Definitions
*   **CLI:** Command-Line Interface. The text-based interface for interacting with the application.
*   **Task:** A single to-do item managed by the system.
*   **Task ID:** A unique integer identifier assigned to each task.
*   **Task Status:** The current state of a task, either "pending" or "completed".

### 2. Overall Description

#### 2.1 System Architecture
The system is mandated to follow a 3-layer architectural pattern to enforce separation of concerns.

*   **2.1.1 Presentation Layer (`main.py`):** Responsible for all user interaction. This layer parses CLI commands and arguments, invokes the appropriate business logic, and formats and displays all output to the user. It contains no business logic.
*   **2.1.2 Business Logic Layer (`task_manager.py`):** Contains the core application logic. It defines the structure and rules for managing tasks (e.g., how to create a task, how to change its status). This layer is completely decoupled from the UI and data storage mechanisms.
*   **2.1.3 Data Layer (`storage.py`):** Responsible for all data persistence. It provides an interface for loading tasks from and saving tasks to a persistent storage medium (a JSON file). It has no knowledge of the business rules.

#### 2.2 Data Model
The fundamental data entity is a **Task**. A Task shall be represented as a dictionary-like object with the following attributes:

| Attribute     | Type    | Constraints                                     | Description                       |
|---------------|---------|-------------------------------------------------|-----------------------------------|
| `id`          | Integer | **Required**, Unique, Non-negative              | The unique identifier for the task. |
| `description` | String  | **Required**, Non-empty                         | The text content of the task.     |
| `status`      | String  | **Required**, Enum (`"pending"`, `"completed"`) | The current state of the task.    |

#### 2.3 User Interface
The system shall be operated exclusively through a Command-Line Interface.

### 3. Functional Requirements

#### 3.1 FR-ADD: Add a New Task
*   **3.1.1 Description:** The system shall allow a user to add a new task to the list.
*   **3.1.2 Trigger:** The user executes the command `add` followed by a string argument for the task description (e.g., `python main.py add "My new task"`).
*   **3.1.3 System Action:**
    1.  A new Task object shall be created.
    2.  The Task's `description` shall be set to the user-provided string.
    3.  The Task's `status` shall be set to `"pending"` by default.
    4.  A unique `id` shall be generated by finding the maximum existing ID and incrementing it by one. If no tasks exist, the ID shall be 1.
    5.  The new Task shall be added to the list of existing tasks.
    6.  The updated list of tasks shall be persisted via the Data Layer.
*   **3.1.4 User Feedback:** A confirmation message shall be printed to the console, including the new task's ID and description (e.g., `Success: Added task 1: "My new task"`).

#### 3.2 FR-LIST: List All Tasks
*   **3.2.1 Description:** The system shall allow a user to view all existing tasks.
*   **3.2.2 Trigger:** The user executes the command `list` (e.g., `python main.py list`).
*   **3.2.3 System Action:** The system shall retrieve the full list of tasks.
*   **3.2.4 User Feedback:**
    *   If tasks exist, they shall be printed in a formatted list, displaying the `id`, `status`, and `description` for each task.
    *   If no tasks exist, the system shall print a message indicating the list is empty (e.g., `No tasks found.`).

#### 3.3 FR-COMPLETE: Mark a Task as Complete
*   **3.3.1 Description:** The system shall allow a user to change a task's status from "pending" to "completed".
*   **3.3.2 Trigger:** The user executes the command `complete` followed by an integer `task_id` (e.g., `python main.py complete 2`).
*   **3.3.3 Pre-condition:** A task with the specified `task_id` must exist.
*   **3.3.4 System Action:**
    1.  The system shall find the task corresponding to the given `task_id`.
    2.  The `status` of that task shall be updated to `"completed"`.
    3.  The updated list of tasks shall be persisted via the Data Layer.
*   **3.3.5 User Feedback:** A confirmation message shall be printed (e.g., `Success: Marked task 2 as completed.`).
*   **3.3.6 Error Condition:** If no task with the specified `task_id` exists, an error message shall be printed (e.g., `Error: Task with ID 2 not found.`), and no data shall be changed.

#### 3.4 FR-REMOVE: Remove a Task
*   **3.4.1 Description:** The system shall allow a user to permanently delete a task.
*   **3.4.2 Trigger:** The user executes the command `remove` followed by an integer `task_id` (e.g., `python main.py remove 3`).
*   **3.4.3 Pre-condition:** A task with the specified `task_id` must exist.
*   **3.4.4 System Action:**
    1.  The system shall find the task corresponding to the given `task_id`.
    2.  The task shall be removed from the list of tasks.
    3.  The updated list of tasks shall be persisted via the Data Layer.
*   **3.4.5 User Feedback:** A confirmation message shall be printed (e.g., `Success: Removed task 3.`).
*   **3.4.6 Error Condition:** If no task with the specified `task_id` exists, an error message shall be printed, and no data shall be changed.

### 4. Non-Functional Requirements

#### 4.1 NFR-PERSIST: Data Persistence
*   **4.1.1 Storage Medium:** All task data shall be stored in a single file named `tasks.json` located in the application's root directory.
*   **4.1.2 Data Format:** The file shall contain a single JSON array, where each element is a Task object conforming to the Data Model (Section 2.2).
*   **4.1.3 Atomicity:** Every state-changing operation (Add, Complete, Remove) must trigger an immediate save of the entire task list to the `tasks.json` file.

#### 4.2 NFR-ROBUST: Error Handling
*   **4.2.1 File Not Found:** On initial load, if `tasks.json` does not exist, the system shall handle the `FileNotFoundError` gracefully and proceed with an empty list of tasks in memory. It shall not crash.
*   **4.2.2 Invalid ID:** Any operation referencing a non-existent `task_id` must fail with a user-friendly error message and must not alter the state of the system.